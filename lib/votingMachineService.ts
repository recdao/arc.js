import { BigNumber } from "bignumber.js";
import { Address, HasContract, Hash } from "./commonTypes";
import { ArcTransactionResult, DecodedLogEntryEvent, TransactionReceiptTruffle } from "./contractWrapperBase";
import { Utils } from "./utils";
import { EventFetcherFactory, Web3EventService } from "./web3EventService";
import { CancelProposalEventResult, CancelVotingEventResult } from "./wrappers/absoluteVote";
import {
  ExecuteProposalEventResult,
  NewProposalEventResult,
  VoteProposalEventResult
} from "./wrappers/commonEventInterfaces";

/**
 * Instantiate a VotingMachineService given the address of any contract
 * that implements the `IntVoteInterface` Arc contract interface.
 */
export class VotingMachineServiceFactory {
  /**
   * Create a new VotingMachineService given a voting machine address
   * @param votingMachineAddress
   */
  public static async create(votingMachineAddress: Address): Promise<VotingMachineService> {
    const contract = await Utils.requireContract("IntVoteInterface");
    return new VotingMachineService(await contract.at(votingMachineAddress));
  }
}

/**
 * Provides the services of any voting machine that implements the `IntVoteInterface`
 * Arc contract interface.  VotingMachineService implements `IntVoteInterface`
 * straight except when transactions are generated then we return `Promise<ArcTransactionResult>`
 * instead of `Promise<TransactionReceiptTruffle>`.
 */
export class VotingMachineService implements HasContract {

  /**
   * Get or watch events fired on the creation of a new proposal.
   */
  public NewProposal: EventFetcherFactory<NewProposalEventResult> =
    Web3EventService.createEventFetcherFactory<NewProposalEventResult>("NewProposal", this);
  /**
   * Get or watch events fired when a vote is cancelled.
   * Note you won't get this from GenesisProtocol whose proposals and votes are not cancellable
   */
  public CancelProposal: EventFetcherFactory<CancelProposalEventResult> =
    Web3EventService.createEventFetcherFactory<CancelProposalEventResult>("CancelProposal", this);
  /**
   * Get or watch events fired when proposals have been executed
   */
  public ExecuteProposal: EventFetcherFactory<ExecuteProposalEventResult> =
    Web3EventService.createEventFetcherFactory<ExecuteProposalEventResult>("ExecuteProposal", this);
  /**
   * Get or watch events fired whenever votes are cast on a proposal
   */
  public VoteProposal: EventFetcherFactory<VoteProposalEventResult> =
    Web3EventService.createEventFetcherFactory<VoteProposalEventResult>("VoteProposal", this);
  /**
   * Get or watch events fired when a voter's vote is cancelled.
   * Note you won't get this from GenesisProtocol whose proposals and votes are not cancellable
   */
  public CancelVoting: EventFetcherFactory<CancelVotingEventResult> =
    Web3EventService.createEventFetcherFactory<CancelVotingEventResult>("CancelVoting", this);

  /**
   * Instantiate VotingMachineService given the voting machine's address.
   *
   * @param votingMachineAddress Address of any contract that implements
   * Arc's `IntVoteInterface`.
   */
  constructor(public contract: IntVoteInterface) {
  }

  /**
   * Get or watch NewProposal events, filtering out proposals that are no longer votable.
   */
  public get VotableProposals(): EventFetcherFactory<NewProposalEventResult> {
    return Web3EventService.createEventFetcherFactory<NewProposalEventResult>("NewProposal", this,
      (error: Error, log: Array<DecodedLogEntryEvent<NewProposalEventResult>>) => {
        if (!error) {
          log = log.filter(async (event: DecodedLogEntryEvent<NewProposalEventResult>) => {
            const proposalId = event.args._proposalId;
            return await this.isVotable(proposalId);
          });
        }
        return { error, log };
      });
  }

  /**
   * Register a new proposal with the given parameters. Every proposal is given a unique ID
   * which is a hash generated by calculating the keccak256 of a packing of an
   * incremented counter and the address of the voting machine.
   * @param options
   */
  public async propose(options: ProposeVoteConfig): Promise<ArcTransactionResult> {
    return this._propose(
      options.numOfChoices,
      options.votingMachineParametersHash,
      options.avatarAddress,
      options.executable);
  }

  /**
   * Cancel the given proposal
   * @param proposalId
   */
  public async cancelProposal(proposalId: Address): Promise<ArcTransactionResult> {
    return this._cancelProposal(proposalId);
  }
  /**
   * Vote on behalf of the owner of the proposal, ie the agent that created it.
   * @param proposalId
   * @param vote What to vote
   * @param voter The owner
   */
  public async ownerVote(options: OwnerVoteOptions): Promise<ArcTransactionResult> {
    return this._ownerVote(options.proposalId, options.vote, options.voter);
  }
  /**
   * Vote on behalf of msgSender
   * @param proposalId
   * @param vote
   */
  public async vote(options: VoteOptions): Promise<ArcTransactionResult> {
    return this._vote(options.proposalId, options.vote);
  }

  /**
   * Vote specified reputation amount
   * @param proposalId
   * @param vote
   * @param rep
   * @param token
   */
  public async voteWithSpecifiedAmounts(options: VoteWithSpecifiedAmountsOptions): Promise<ArcTransactionResult> {
    return this._voteWithSpecifiedAmounts(options.proposalId, options.vote, options.rep);
  }

  /**
   * Cancel voting on the proposal.
   * @param proposalId
   */
  public async cancelVote(proposalId: Address): Promise<ArcTransactionResult> {
    return this._cancelVote(proposalId);
  }

  /**
   * Get the number of voting choices allowed by the proposal.
   * @param proposalId
   */
  public async getNumberOfChoices(proposalId: Address): Promise<number> {
    return this._getNumberOfChoices(proposalId);
  }

  /**
   * Get whether the proposal is in a state where it can be voted-upon.
   * @param proposalId
   */
  public async isVotable(proposalId: Address): Promise<boolean> {
    return this._isVotable(proposalId);
  }

  /**
   * Get the number of votes currently cast on the given choice.
   * @param proposalId
   * @param vote
   */
  public async voteStatus(options: VoteStatusOptions): Promise<BigNumber> {
    return this._voteStatus(options.proposalId, options.vote);
  }

  /**
   * get whether voters are allowed to cast an abstaining vote on these proposals.
   */
  public async isAbstainAllow(): Promise<boolean> {
    return this._isAbstainAllow();
  }

  /**
   * Attempt to execute the given proposal vote.
   * @param proposalId
   */
  public async execute(proposalId: Hash): Promise<ArcTransactionResult> {
    return this._execute(proposalId);
  }

  /**
   * Return an array of the current counts of each vote choice on the proposal.
   * For straight Abstain, Yes and No votes you can use the values of the
   * `BinaryVoteResult` enum to dereference the array.  The Abstain vote
   * (in the zeroeth position) is always given even if the voting machine
   * does not allow abstentions.
   *
   * @param proposalId
   */
  public async getCurrentVoteStatus(proposalId: Address): Promise<Array<BigNumber>> {

    let numChoices = await this._getNumberOfChoices(proposalId);
    const abstainAllowed = await this._isAbstainAllow();
    // when abstaining is not allowed, numChoices doesn't include it, but we always return it here, even if always zero
    if (!abstainAllowed) {
      ++numChoices;
    }

    const voteTotals = new Array<BigNumber>(numChoices);

    for (let choice = 0; choice < numChoices; ++choice) {
      const voteTotal = await this._voteStatus(proposalId, choice);
      voteTotals[choice] = voteTotal;
    }

    return voteTotals;
  }

  private async _propose(
    numOfChoices: number,
    proposalParameters: Hash,
    avatarAddress: Address,
    execute: Address): Promise<ArcTransactionResult> {

    if (!avatarAddress) {
      throw new Error(`avatar is not defined`);
    }
    if (!proposalParameters) {
      throw new Error(`proposalParameters is not defined`);
    }

    if (!execute) {
      throw new Error(`execute is not defined`);
    }

    if (typeof numOfChoices !== "number") {
      throw new Error(`numOfChoices must be a number`);
    }

    return new ArcTransactionResult(
      await this.contract.propose(numOfChoices, proposalParameters, avatarAddress, execute));
  }

  private async _cancelProposal(proposalId: Hash): Promise<ArcTransactionResult> {
    if (!proposalId) {
      throw new Error(`proposalId is not defined`);
    }
    return new ArcTransactionResult(await this.contract.cancelProposal(proposalId));
  }

  private async _ownerVote(proposalId: Hash, vote: number, voterAddress: Address): Promise<ArcTransactionResult> {
    if (!proposalId) {
      throw new Error(`proposalId is not defined`);
    }
    this._validateVote(vote);
    if (!voterAddress) {
      throw new Error(`voterAddress is not defined`);
    }
    return new ArcTransactionResult(await this.contract.ownerVote(proposalId, vote, voterAddress));
  }

  private async _vote(proposalId: Hash, vote: number): Promise<ArcTransactionResult> {
    if (!proposalId) {
      throw new Error(`proposalId is not defined`);
    }
    this._validateVote(vote);
    return new ArcTransactionResult(await this.contract.vote(proposalId, vote));
  }

  private async _voteWithSpecifiedAmounts(
    proposalId: Hash,
    vote: number,
    rep: BigNumber): Promise<ArcTransactionResult> {

    if (!proposalId) {
      throw new Error(`proposalId is not defined`);
    }
    this._validateVote(vote);
    // tokens, the last parameter, is ignored
    return new ArcTransactionResult(
      await this.contract.voteWithSpecifiedAmounts(proposalId, vote, rep, new BigNumber(0)));
  }

  private async _cancelVote(proposalId: Hash): Promise<ArcTransactionResult> {
    if (!proposalId) {
      throw new Error(`proposalId is not defined`);
    }
    return new ArcTransactionResult(await this.contract.cancelVote(proposalId));
  }

  private async _getNumberOfChoices(proposalId: Hash): Promise<number> {
    if (!proposalId) {
      throw new Error(`proposalId is not defined`);
    }
    return (await this.contract.getNumberOfChoices(proposalId)).toNumber();
  }

  private async _isVotable(proposalId: Hash): Promise<boolean> {
    if (!proposalId) {
      throw new Error(`proposalId is not defined`);
    }
    return await this.contract.isVotable(proposalId);
  }

  private async _voteStatus(proposalId: Hash, vote: number): Promise<BigNumber> {
    if (!proposalId) {
      throw new Error(`proposalId is not defined`);
    }
    this._validateVote(vote);
    return await this.contract.voteStatus(proposalId, vote);
  }

  private async _isAbstainAllow(): Promise<boolean> {
    return await this.contract.isAbstainAllow();
  }

  private _validateVote(vote: number): void {
    if ((typeof vote !== "number") || (vote < 0)) {
      throw new Error(`vote must be a number greater than or equal to zero`);
    }
  }

  private async _execute(proposalId: Hash): Promise<ArcTransactionResult> {
    if (!proposalId) {
      throw new Error(`proposalId is not defined`);
    }
    return new ArcTransactionResult(await this.contract.execute(proposalId));
  }
}

/**
 * The Arc contract `IntVoteInterface`.
 */
export interface IntVoteInterface {
  propose(numOfChoices: number,
          proposalParameters: Hash,
          avatar: Address,
          execute: Address): Promise<TransactionReceiptTruffle>;
  cancelProposal(proposalId: Hash): Promise<TransactionReceiptTruffle>;
  ownerVote(proposalId: Hash, vote: number, voter: Address): Promise<TransactionReceiptTruffle>;
  vote(proposalId: Hash, vote: number): Promise<TransactionReceiptTruffle>;
  voteWithSpecifiedAmounts(
    proposalId: Hash,
    vote: number,
    rep: BigNumber,
    token: BigNumber): Promise<TransactionReceiptTruffle>;
  cancelVote(proposalId: Hash): Promise<TransactionReceiptTruffle>;
  getNumberOfChoices(proposalId: Hash): Promise<BigNumber>;
  isVotable(proposalId: Hash): boolean;
  voteStatus(proposalId: Hash, choice: number): Promise<BigNumber>;
  isAbstainAllow(): Promise<boolean>;
  execute(proposalId: Hash): Promise<TransactionReceiptTruffle>;
}

export interface ProposeVoteConfig {
  /**
   * The DAO's avatar under which the proposal is being made.
   */
  avatarAddress: Address;
  /**
   * parameters of the voting machine
   */
  votingMachineParametersHash: Hash;
  /**
   * number of choices when voting.  Must be between 1 and 10.
   */
  numOfChoices: number;
  /**
   * contract that implements ExecutableInterface to invoke if/when the vote passes
   */
  executable: Address;
}

export interface OwnerVoteOptions {
  proposalId: Hash;
  vote: number;
  voter: Address;
}

export interface VoteOptions {
  proposalId: Hash;
  vote: number;
}

export interface VoteWithSpecifiedAmountsOptions {
  proposalId: Hash;
  rep: BigNumber;
  vote: number;
}

export interface VoteStatusOptions {
  proposalId: Hash;
  vote: number;
}
