import { BigNumber } from "bignumber.js";
import { Address, HasContract, Hash } from "./commonTypes";
import { ArcTransactionResult, DecodedLogEntryEvent, TransactionReceiptTruffle } from "./contractWrapperBase";
import { Utils } from "./utils";
import { EventFetcherFactory, Web3EventService } from "./web3EventService";
import { CancelProposalEventResult, CancelVotingEventResult } from "./wrappers/absoluteVote";
import {
  ExecuteProposalEventResult,
  NewProposalEventResult,
  VoteProposalEventResult
} from "./wrappers/commonEventInterfaces";

/**
 * Instantiate a VotingMachineService given the address of any contract
 * that implements the `IntVoteInterface` Arc contract interface.
 */
export class VotingMachineServiceFactory {

  constructor(private web3EventService: Web3EventService) {
  }
  /**
   * Create a new VotingMachineService given a voting machine address
   * @param votingMachineAddress
   */
  public async create(votingMachineAddress: Address): Promise<VotingMachineService> {
    const contract = await Utils.requireContract("IntVoteInterface");
    return new VotingMachineService(
      await contract.at(votingMachineAddress),
      votingMachineAddress,
      this.web3EventService);
  }
}

/**
 * Provides the services of any voting machine that implements the `IntVoteInterface`
 * Arc contract interface.  VotingMachineService implements `IntVoteInterface`
 * straight except when transactions are generated then we return `Promise<ArcTransactionResult>`
 * instead of `Promise<TransactionReceiptTruffle>`.
 */
export class VotingMachineService implements HasContract {

  public get address(): Address {
    return (this.contract as any).address;
  }

  /**
   * Get or watch events fired on the creation of a new proposal.
   */
  public NewProposal: EventFetcherFactory<NewProposalEventResult> =
    this.web3EventService.createEventFetcherFactory<NewProposalEventResult>("NewProposal", this);
  /**
   * Get or watch events fired when a vote is cancelled.
   * Note you won't get this from GenesisProtocol whose proposals and votes are not cancellable
   */
  public CancelProposal: EventFetcherFactory<CancelProposalEventResult> =
    this.web3EventService.createEventFetcherFactory<CancelProposalEventResult>("CancelProposal", this);
  /**
   * Get or watch events fired when proposals have been executed
   */
  public ExecuteProposal: EventFetcherFactory<ExecuteProposalEventResult> =
    this.web3EventService.createEventFetcherFactory<ExecuteProposalEventResult>("ExecuteProposal", this);
  /**
   * Get or watch events fired whenever votes are cast on a proposal
   */
  public VoteProposal: EventFetcherFactory<VoteProposalEventResult> =
    this.web3EventService.createEventFetcherFactory<VoteProposalEventResult>("VoteProposal", this);
  /**
   * Get or watch events fired when a voter's vote is cancelled.
   * Note you won't get this from GenesisProtocol whose proposals and votes are not cancellable
   */
  public CancelVoting: EventFetcherFactory<CancelVotingEventResult> =
    this.web3EventService.createEventFetcherFactory<CancelVotingEventResult>("CancelVoting", this);
  /**
   * Instantiate VotingMachineService given the voting machine's address.
   *
   * @param votingMachineAddress Address of any contract that implements
   * Arc's `IntVoteInterface`.
   */
  constructor(
    public contract: IntVoteInterface,
    public votingMachineAddress: Address,
    private web3EventService: Web3EventService) {
  }

  public getParameters(votingMachineParamsHash: Hash): Promise<Array<any>> {
    return (this.contract as any).parameters(votingMachineParamsHash);
  }

  /**
   * Get or watch NewProposal events, filtering out proposals that are no longer votable.
   */
  public get VotableProposals(): EventFetcherFactory<NewProposalEventResult> {
    return this.web3EventService.createEventFetcherFactory<NewProposalEventResult>("NewProposal", this,
      (error: Error, log: Array<DecodedLogEntryEvent<NewProposalEventResult>>) => {
        if (!error) {
          log = log.filter(async (event: DecodedLogEntryEvent<NewProposalEventResult>) => {
            const proposalId = event.args._proposalId;
            return await this.isVotable(proposalId);
          });
        }
        return { error, log };
      });
  }
  /**
   * Register a new proposal with the given parameters. Every proposal is given a unique ID
   * which is a hash generated by calculating the keccak256 of a packing of an
   * incremented counter and the address of the voting machine.
   * @param numOfChoices
   * @param proposalParameters
   * @param avatarAddress
   * @param execute
   */
  public async propose(
    numOfChoices: number,
    proposalParameters: Hash,
    avatarAddress: Address,
    execute: Address): Promise<ArcTransactionResult> {

    if (!avatarAddress) {
      throw new Error(`avatar is not defined`);
    }
    if (!proposalParameters) {
      throw new Error(`proposalParameters is not defined`);
    }

    if (!execute) {
      throw new Error(`execute is not defined`);
    }

    if (typeof numOfChoices !== "number") {
      throw new Error(`numOfChoices must be a number`);
    }

    return new ArcTransactionResult(
      await this.contract.propose(numOfChoices, proposalParameters, avatarAddress, execute));
  }

  /**
   * Cancel the given proposal
   * @param proposalId
   */
  public async cancelProposal(proposalId: Hash): Promise<ArcTransactionResult> {
    if (!proposalId) {
      throw new Error(`proposalId is not defined`);
    }
    return new ArcTransactionResult(await this.contract.cancelProposal(proposalId));
  }

  /**
   * Vote on behalf of the owner of the proposal, ie the agent that created it.
   * @param proposalId
   * @param vote What to vote
   * @param voter The owner
   */
  public async ownerVote(vote: number, voterAddress: Address, proposalId: Hash): Promise<ArcTransactionResult> {
    if (!proposalId) {
      throw new Error(`proposalId is not defined`);
    }
    this._validateVote(vote);
    if (!voterAddress) {
      throw new Error(`voterAddress is not defined`);
    }
    return new ArcTransactionResult(await this.contract.ownerVote(proposalId, vote, voterAddress));
  }

  /**
   * Vote on behalf of msgSender
   * @param proposalId
   * @param vote
   * @param onBehalfOf Optional agent on whose behalf to vote.
   */
  public async vote(vote: number, proposalId: Hash, onBehalfOf?: Address): Promise<ArcTransactionResult> {
    if (!proposalId) {
      throw new Error(`proposalId is not defined`);
    }
    this._validateVote(vote);
    return new ArcTransactionResult(
      await this.contract.vote(proposalId, vote, onBehalfOf ? { from: onBehalfOf } : undefined));
  }

  /**
   * Vote specified reputation amount
   * @param proposalId
   * @param vote
   * @param reputation
   */

  public async voteWithSpecifiedAmounts(
    vote: number,
    reputation: BigNumber,
    proposalId: Hash): Promise<ArcTransactionResult> {

    if (!proposalId) {
      throw new Error(`proposalId is not defined`);
    }
    this._validateVote(vote);
    // tokens, the last parameter, is ignored
    return new ArcTransactionResult(
      await this.contract.voteWithSpecifiedAmounts(proposalId, vote, reputation, new BigNumber(0)));
  }

  /**
   * Cancel voting on the proposal.
   * @param proposalId
   */
  public async cancelVote(proposalId: Hash): Promise<ArcTransactionResult> {
    if (!proposalId) {
      throw new Error(`proposalId is not defined`);
    }
    return new ArcTransactionResult(await this.contract.cancelVote(proposalId));
  }

  /**
   * Get the number of voting choices allowed by the proposal.
   * @param proposalId
   */
  public async getNumberOfChoices(proposalId: Hash): Promise<number> {
    if (!proposalId) {
      throw new Error(`proposalId is not defined`);
    }
    return (await this.contract.getNumberOfChoices(proposalId)).toNumber();
  }

  /**
   * Get whether the proposal is in a state where it can be voted-upon.
   * @param proposalId
   */
  public async isVotable(proposalId: Hash): Promise<boolean> {
    if (!proposalId) {
      throw new Error(`proposalId is not defined`);
    }
    return await this.contract.isVotable(proposalId);
  }

  /**
   * Get the number of votes currently cast on the given choice.
   * @param proposalId
   * @param vote
   */
  public async voteStatus(vote: number, proposalId: Hash): Promise<BigNumber> {
    if (!proposalId) {
      throw new Error(`proposalId is not defined`);
    }
    this._validateVote(vote);
    return await this.contract.voteStatus(proposalId, vote);
  }

  /**
   * get whether voters are allowed to cast an abstaining vote on these proposals.
   */
  public async isAbstainAllow(): Promise<boolean> {
    return await this.contract.isAbstainAllow();
  }

  /**
   * Attempt to execute the given proposal vote.
   * @param proposalId
   */

  public async execute(proposalId: Hash): Promise<ArcTransactionResult> {
    if (!proposalId) {
      throw new Error(`proposalId is not defined`);
    }
    return new ArcTransactionResult(await this.contract.execute(proposalId));
  }

  /**
   * Return an array of the current counts of each vote choice on the proposal.
   * For straight Abstain, Yes and No votes you can use the values of the
   * `BinaryVoteResult` enum to dereference the array.  The Abstain vote
   * (in the zeroeth position) is always given even if the voting machine
   * does not allow abstentions.
   *
   * @param proposalId
   */
  public async getCurrentVoteStatus(proposalId: Address): Promise<Array<BigNumber>> {

    let numChoices = await this.getNumberOfChoices(proposalId);
    const abstainAllowed = await this.isAbstainAllow();
    // when abstaining is not allowed, numChoices doesn't include it, but we always return it here, even if always zero
    if (!abstainAllowed) {
      ++numChoices;
    }

    const voteTotals = new Array<BigNumber>(numChoices);

    for (let choice = 0; choice < numChoices; ++choice) {
      const voteTotal = await this.voteStatus(choice, proposalId);
      voteTotals[choice] = voteTotal;
    }

    return voteTotals;
  }

  private _validateVote(vote: number): void {
    if ((typeof vote !== "number") || (vote < 0)) {
      throw new Error(`vote must be a number greater than or equal to zero`);
    }
  }
}

/**
 * The Arc contract `IntVoteInterface`.
 */
export interface IntVoteInterface {
  propose(numOfChoices: number,
    proposalParameters: Hash,
    avatar: Address,
    execute: Address): Promise<TransactionReceiptTruffle>;
  cancelProposal(proposalId: Hash): Promise<TransactionReceiptTruffle>;
  ownerVote(proposalId: Hash, vote: number, voter: Address): Promise<TransactionReceiptTruffle>;
  // options is not part of Arc, rather is part of truffle. Declared here for onBehalfOf
  vote(proposalId: Hash, vote: number, options?: { from: Address }): Promise<TransactionReceiptTruffle>;
  voteWithSpecifiedAmounts(
    proposalId: Hash,
    vote: number,
    rep: BigNumber,
    token: BigNumber): Promise<TransactionReceiptTruffle>;
  cancelVote(proposalId: Hash): Promise<TransactionReceiptTruffle>;
  getNumberOfChoices(proposalId: Hash): Promise<BigNumber>;
  isVotable(proposalId: Hash): boolean;
  voteStatus(proposalId: Hash, choice: number): Promise<BigNumber>;
  isAbstainAllow(): Promise<boolean>;
  execute(proposalId: Hash): Promise<TransactionReceiptTruffle>;
}
